# -*- coding: utf-8 -*-
"""unparallel scenario-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PdArqYgVo_OoiLJWFbXdSChcIrB4SxkN
"""

import csv
import math
import numpy as np
import pandas as pd
import random
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
import warnings
#suppress warnings
warnings.filterwarnings('ignore')

def lineseg_dist(p, a, b):

    # normalized tangent vector
    d = np.divide(b - a, np.linalg.norm(b - a))

    # signed parallel distance components
    s = np.dot(a - p, d)
    t = np.dot(p - b, d)

    # clamped parallel distance
    h = np.maximum.reduce([s, t, 0])

    # perpendicular distance component
    c = np.cross(p - a, d)

    return np.hypot(h, np.linalg.norm(c))

mu_0 = 4 * math.pi * 1e-7  # Permeability of free space

# Set up the parameters for the data
I_values = np.linspace(100,400,4)  # Values of I to use
axl=[100,90,80,70]
ayl=[100,90,80,70]
azl=[1,2,3]
bxl=[-100,-90,-80,-70]
byl=[-100,-90,-80,-70]
bzl=[1,2,3]
pxl=[-4,-2,2,4]
pyl=[-4,-2,2,4]
pz=0
header_row = ['I', 'ax', 'ay', 'az', 'bx', 'by', 'bz', 'px', 'py','B']

# Create a list to store the rows of data
data_rows = []
for i in I_values:
  for ax in axl:
    for ay in ayl:
      for az in azl:
        for bx in bxl:
          for by in byl:
            for bz in bzl:
              for px in pxl:
                for py in pyl:
                  a=[ax,ay,az]
                  a=np.array(a)
                  b=[bx,by,bz]
                  b=np.array(b)
                  p=[px,py,pz]
                  p=np.array(p)
                  R=lineseg_dist(p,a,b)
                  B = mu_0 * i / (2 * math.pi * R)
                  data_rows.append([i, ax, ay, az, bx, by, bz, px, py, B])


# Write the data to a CSV file
with open('unparallel_data.csv', 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(header_row)
    writer.writerows(data_rows)

data=pd.read_csv('unparallel_data.csv', sep=',')

#data=preprocessing.normalize(data)
data=(data-data.mean())/data.std()
data

Inoise = np.random.normal(np.mean(np.array(data['I'])),1,400)
axnoise = np.random.normal(np.mean(np.array(data['ax'])),1,400)
aynoise = np.random.normal(np.mean(np.array(data['ay'])),1,400)
aznoise = np.random.normal(np.mean(np.array(data['az'])),1,400)
bxnoise = np.random.normal(np.mean(np.array(data['bx'])),1,400)
bynoise = np.random.normal(np.mean(np.array(data['by'])),1,400)
bznoise = np.random.normal(np.mean(np.array(data['bz'])),1,400)
pxnoise = np.random.normal(np.mean(np.array(data['px'])),1,400)
pynoise = np.random.normal(np.mean(np.array(data['py'])),1,400)
Bnoise = np.random.normal(np.mean(np.array(data['B'])),1,400)
noise=pd.DataFrame({'I': Inoise, 'ax': axnoise, 'ay': aynoise, 'az': aznoise, 
                    'bx':bxnoise, 'by':bynoise, 'bz':bznoise, 'px': pxnoise,
                    'py':pynoise, 'B':Bnoise})
data=data.append(noise, ignore_index=True)
data=np.array(data)
print(len(data))

# Split the data into training and testing sets
num_training_samples = 103000
X=[[row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7],row[8]] for row in data]
y=[row[9] for row in data]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, shuffle=True)
# Create the regression models
model=XGBRegressor()
# Fit the regression models iteratively
train_sizes = range(1000, num_training_samples, 1000)
losses = []
model_losses = []
n=0
for train_size in train_sizes:
  X_trainn = np.array(X_train[:train_size])
  y_trainn = np.array(y_train[:train_size])
  model.fit(X_trainn, y_trainn)
  y_pred = model.predict(X_test)
  loss = mean_squared_error(y_test, y_pred)
  losses.append(loss)
  print(f'Iteration {n}:',loss)
  n+=1

# Plot model losses
plt.plot(losses, label='XGBoostRegression')
plt.xlabel("Iterations")
plt.ylabel("Loss")
plt.title("Loss Value of magnetic field intensity")
plt.legend(loc="upper right")

plt.show()

pred=model.predict(X_test)
regression_mse = mean_squared_error(y_test, pred)
print("mean square error:", regression_mse)
acc=0
for i in range(len(pred)):
  if abs(pred[i]==y_test[i])<=0.1:
    acc+=1
print("accuracy:", acc/len(pred))